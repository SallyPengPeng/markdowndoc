## 自我介绍

您好，我叫彭红丽。2017年毕业于武汉理工大学通信工程专业，毕业5年，任职过2家公司。我是一个学习能力强、有责任心、有毅力、对开发有热情的女生。

我的工作经历可能和一般的开发不太一样，我毕业后前2年是测试，3年前，2020年初，我从测试转岗为前端开发。由于疫情的原因，公司的业务量相对减少，我有了一部分的空余时间，在那之前我一直挺想做开发的，所以我制定了学习计划。后来也顺利通过了转岗考核，但我没有停下学习的脚步，我一直在进步，现在我已经能独立带队一个项目的前端，并且能够胜任前端架构级别的开发，这充分证明了我的自律、毅力和学习能力。

因为有测试的经历，所以我更擅长从用户、需求、测试的角度思考，我做事有逻辑，开发认真严谨细致。前2年的测试工作，对我的开发起到了非常大的促进和辅助作用。这在工作中也有很显著的表现，我负责或者开发的任务，从开发文档、开发过程、代码提交、归纳总结都遵循着规范的流程，有明确的计划安排，很少出现需求理解偏差或严重bug的情况。

我在当前就职公司已经3年多了，我的年龄也不小了，5年工作经历在职场是一个分界线。我觉得我需要走出舒适区，步入更大的平台。我很感激现在的公司，让我能够有转岗的机会，让我从事自己喜爱有热情的工作。但现在我发现，我在这里能够得到的技术、包括薪资的提升都很有限。所以经过慎重考虑和准备后，还是决定寻求更多的机会。

我始终相信一句话，只要你足够努力，就会有很多机会。我最大的优点就是够努力、肯钻研、学的快。所以我觉得不管在什么环境，做什么，我都可以以最快的速度适应并融入。



**不带测试经验自我介绍**

您好，我叫彭红丽。2017年毕业于武汉理工大学通信工程专业，毕业5年，任职过2家公司。我是一个学习能力强、有责任心、有毅力、对开发有热情的女生。

在当前公司，我可以独立带队一个项目的前端开发，并且能够胜任前端架构级别的开发。我参与的项目，同事、领导对我的评价都很高，我接手的任务，前端基本未出过重大bug，前端开发规范、流程都有严格要求和文档记录。

我做事有逻辑，开发认真严谨细致。这对我的日常工作产生了比较明显的正反馈，我负责或者开发的任务，从开发文档、开发过程、代码提交、归纳总结都遵循着规范的流程，有明确的计划安排，很少出现需求理解偏差或严重bug的情况。

我在当前就职公司已经3年多了，我的年龄也不小了，5年工作经历在职场是一个分界线。我觉得我需要走出舒适区，步入更大的平台。我也很感激现在的公司，我学到了很多，也结识了一些志同道合的朋友。但我目前在这里能够得到的技术的提升比较有限。所以经过慎重考虑和准备后，还是决定寻求更多的机会。

我最大的优点就是够努力、肯钻研、学的快、适应环境能力超强。我认为我完全可以胜任这个工作，我可以充分发挥我的能力，为公司的产品奉献一份力量。



年终奖、五险一金、餐补、包吃 、房补、试用期、涨薪机会、年假、技术培训、周末加班

## 为什么选择离职

1、薪资和福利待遇的原因。因为疫情的影响，公司这2年处于一个低迷的状态，所以涨薪额度特别有限。还有就是公司的社保没有按照工资全额交。

2、个人能力提升。我在公司3年多，做过业务开发、也担任了架构开发。目前阶段，我还是希望能够做一些有挑战的、没有尝试过的项目，能够在30岁之前，让技术水平加快上升一个等级。

3、身边一些关系比较好的朋友都相继离职了，我现在其实和到一个新公司没有太大区别。那我当然想要挑战一下自己

4、抽空考驾照

## 人生规划和期望

1、技术方向。除了工作中用到的技术，自己还打算在github写一些开源的工程，更多提升自己的能力和价值

2、业务方向。从工作中了解业务，从业务角度，去分析、升级用到的技术工具、框架、插件等，从技术层面简化、优化业务使用的工作软件

3、生活。报健身房、游泳班，加强体能锻炼。继续学习尤克里里，让自己的生活有活力又丰富多彩

## 为什么从测试转岗前端

1、个人性格。我的性格属于踏实着冒险。相比验证，我更擅长也更喜欢创造，而前端开发，写的代码可以直观的从页面上看到，可以写一些很有意思的东西，我喜欢在稳定中，创造让人眼前一亮的输出

2、待遇。同等条件的测试和开发，大部分情况下，开岗位的工资会更高

3、机会。2020年初，疫情，我有时候有精力学习前端开发，公司当初也是支持的

那么既然我自己喜欢开发，又有机会转，挣得工资也更多，那我当然愿意拼搏努力一下啦，事实证明，我的选择是正确且成功的。

## 项目相关

### 嘉实基金

嘉实基金投资理财系统，我从技术角度和业务角度讲解。

首先是业务角度介绍。

1. 嘉实投资理财系统，是将投资意向、指令管理、风控管理、头寸管理等流程整合在一个平台，实现一体化的流畅业务操作、全面的风险管理和数据驱动的投资决策能力
2. 系统融合了多个业务，包括银行间回购、银行间现券、交易所回购、交易所现券等，我主要参与的是银行间回购业务的测试和开发。银行间回购是指正回购方（卖出回购方、资金融入方）在将债券出质给逆回购方（买入返售方、资金融出方）融入资金的同时，双方约定在将来某一指定日期，由正回购方按约定回购利率计算的资金额向逆回购方返回资金，逆回购方向正回购方返回原出质债券的融资行为。
3. 我参与了银行间回购的整个流程，指令的整个流程中，风控、头寸在一个或多个环节中参与，以正回购方向 描述：
   1. 基金经理依据日终余额确定投资意向，风控、头寸指令类别的校验会对指令要素进行校验，通过的指令才可下达成功。头寸 资金增加 预测流入、预测流出
   2. 交易员接收到基金经理下达的指令，选择合适的交易对手方下达委托，头寸 资金增加在途金额，持仓将委托中涉及的债券冻结
   3. 交易系统接收到对手方成交报价后，持仓对冲掉委托时冻结的债券，增加质押债券。主要目的是，对手方未成交前，报价是可以修改的，所以债券是冻结，成交后变成已质押
   4. 如果清算速度是T+0，那么当前交易日，需要进行首期交收，头寸资金 对冲委托时在途，增加当前余额。
   5. 在指令上录入的回购期限所产生的实际占款天数后，需要进行到期交收，头寸资金对冲当前余额试仓，对冲已质押

然后从技术角度简单介绍，具体技术问题在脚手架和组件库项目详细介绍。

嘉实的系统，是将所有的应用整合在了一个平台，可以一体化流畅操作，公共代码只用写一次，方便统一管理。缺点是单页面应用非常庞大，多人协作成本高，开发/构建时间长，依赖升级回归成本高。

### 华润信托

华润信托项目，我从技术角度 和 业务角度讲解。

首先从业务角度介绍。

1. 华润信托项目做的是委外业务，也就是银行理财资金委托外部投资，华润信托是作为委外业务的委托人即管理人端

2. 系统实现了什么功能呢？开放统一接口，接入外部指令（招银理财、招行私行），也支持资金方直接在委外系统下达指令。指令下达后，提供指令执行页面汇总统计指令，交易员可以在指令执行页面可以下达委托、基金经理可进行撤销、修改指令等一系列操作。

3. 我在这个项目的职责是 专注指令管理、产品管理、系统监控等子应用开发。
   - 指令管理，开发指令创建表单 供基金经理录入指令，开发 指令总览、指令执行、指令查询等页面，根据权限控制提供给不同的角色使用。
   - 产品管理，维护信托计划、子层标的，维护产品的基础信息以及一些额外的信息，方便管理员直接在统一系统查询和维护产品
   - 系统监控，与上游同步 成交监控、状态监控，招政托管 文件监控：01 开户申请 02开户确认 03指令申请 04成交确认

然后从技术角度介绍：

1. 基于react脚手架 基于iframe子应用版本模式，根据用户需求融合了指令管理、产品管理、系统监控等子应用。自带了用户管理、角色管理、权限控制等功能，具体实现，我会在脚手架项目中详细介绍
2. 好处：系统接耦，每个子应用可以单独开发和发版。回归测试任务量低
3. 缺点是配置和业务公共部分，每个子应用都需要写一遍。

### 除了react，用过其他框架吗

目前没有，现在的工作没有机会接触其他的框架，自己以前有了解过一些，对于react我之前也是0基础入门的，全是自学的。现在的交易系统一开始对我来说也是很有挑战性的项目。我觉得只要基础扎实，新技术、新框架，学起来是很快的。毕竟技术是日新月异的，哪怕现在掌握了，未来仍然是一个不断学习的过程，所以我觉得相对于现在是否掌握的牢固，学习能力更重要。

### 脚手架介绍

基于react的微前端应用脚手架，使用iframe实现微应用。实际使用时，有一个主应用和多个子应用，主应用提供页面维护所有子应用的配置信息。都依赖相同的这个脚手架工程。主应用实现整体layout，包括左侧菜单栏、header、tab栏。页面部分使用iframe引入子应用。

1. 路由使用react-router路由，使用了CacheRoute。可以满足缓存上一页的功能。因为Route不匹配时，组件会丢失，使用Children prop可以控制render，不管Route是否匹配，页面都不会丢失。当切换页面时，原页面增加一个style=“display: none”，视觉上看不到页面了，但其实保留了页面的相关数据和状态，当回到页面时，去掉style=“display: none”

   主应用的`CacheRoute`：主应用每个页面一个，iframe只保留第一个页面使用`CacheRoute`。子应用内部多个页面维护多个`CacheRoute`

2. 可配置的路由菜单。提供前端页面供用户配置菜单url，初始化时，通过接口获取用户有权限的页面，动态生成菜单。

3. 动态加载组件。目前使用的是`react-loadable`，从而支持代码分割、延时、loading过程显示其它组件。

4. 应用间通信。使用`postMessage：otherWindow.postMessage(message, targetOrigin, [transfer]);`，实现主应用与子应用之间通信；另外封装了msgCenter 统一消息管理，可以实现通信

5. 用户存储，封装统一store管理用户存储，默认使用sessionStorage存储。存在主应用和多个子应用，每个子应用存储自身数据，get和set都加上appId的前缀。

6. 完善的组件库。引入antd、ag-grid、echarts等组件库，部分组件基于投资交易系统的特性，做二次封装，使业务开发时能够专注业务需求的开发，使用更统一、方便，不用多次书写重复代码。

7. 引入less、scss语法，业务代码提供配置所需要的主题，在打包开始前，先将主题样式文件打包，用户可以切换主题，切换后的主题应用到主应用和所有子应用

8. 使用Request、fetch封装各种网络请求API，统一api调用，入参规范格式，增加loading。包括常规的请求get post put delete等，还封装了一些工具：easyApi、增加请求装饰器 response/retry/norepeat

   norepeat: 使用了类方法装饰器，装饰器在编译阶段就执行。在装饰器函数顶部定义局部变量初始是false，在descriptor.value判断，如果是false，就执行原方法，如果true，就拒绝，并提示重复请求，当接口调用完毕后标志位重置为false

   - `target`：类的原型对象，类名.prototype。装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型

   - `name`：所要装饰的属性名

   - `descriptor`：该属性的描述对象（最常用）

   增加了功能：

   1. 拼接完整url，业务开发只用关注具体的接口url，前面http开头的base部分统一拼接。
   2. 提交表单时，禁用提交按钮防止二次提交。method 是post 或者put，查找到提交的按钮，设置disable是true。接口返回后，去除
   3. 因为fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，所以使用Promise再次封装，对错误进行reject
   4. 增加超时处理，原fetch请求，再实例化一个Promise请求，用来计时，使用`promise.race`实现	

### 组件库

引入antd、ag-grid、echarts等组件库，部分组件基于投资交易系统的特性，做二次封装，使业务开发时能够专注业务需求的开发，使用更统一、方便，不用多次书写重复代码。

1、权限管理：增加btnCode，结合主应用菜单管理、权限设置，可配置不同用户对页面、按钮访问权限

2、组件优化：例如将antd-form 和ag-grid结合封装SearchFormTable、PageTable等

3、数据请求：使用Request、fetch封装各种网络请求API，提供超时、loading等配置

5、额外功能：增加大数运算、excel解析等交易系统常用组件

**权限管理**

考虑不同页面、页面按钮，都需要针对不同角色用户设置权限

1. 菜单管理：增加需要控制权限的页面以及页面中的按钮，新增时会生成唯一的btnCode，这样页面、页面按钮和btnCode是一一对应的，在前端代码书写时，写入对应的btnCode。
2. 权限控制，展示页面 和页面按钮树，管理员针对不同用户勾选有权限的页面和按钮
3. 当用户登录时，通过用户id获取到用户有权限的页面和按钮
   1. 渲染菜单列表时，仅渲染有权限的菜单
   2. 渲染页面时，hidden无权限的按钮

**组件优化**

引入多个组件库，针对投资交易系统的特性，做二次封装，避免业务开发书写重复代码，维护多个地方

1. ag-grid二次封装 。ag-grid的优势：都有的功能：行排序、编辑单元格、固定列、子表格、行列合并

   - 可以直接表头筛选，浮动filter

   - 可以直接表格导出excel

   - 右键扩展

   - 表头和cell toolTip

   - 范围选择

   - 特性：

     - 引入searchApi，用户只用配置api 和url，就可以自动服务端获取数据，然后setRowData

     - 特殊格式列，如数值，包括小数、金额等、日期。直接统一配置 filter、formatterParams等配置，不需要业务代码重复书写

     - 单位切换，交易金额涉及金额较多，直接将表格和Radio集合，点击Radio切换配置的数值列的展示

     - 封装编辑单元格通用模版和样式，用户只需要简单配置，和其他组件结合，inputNumber、Date、Select

     - 保存表格模版，配置tableId，存在localStorage

     - ag-grid和form结合，组合成 SearchFormTable、PageTable、SearchTable、ClientPageTable等，实现用户在表单录入筛选项，点击搜索，就可以看到表格数据更改，整体性
2. inputNumber二次封装

   1. 封装展示默认千分号功能、配置缩放的，在onBlur 或onChange去除格式，从而被form正确获取到

   2. `PercentNumber` `HundredNumber` `TenThousandNumber` `HundredMillionNumber`，直接写入需要的配置，例如addonAfter、min、scale

   3. 显示人民币大写
3. Select二次封装
   1. defaultSelectFirstOption，默认选择第一项，就是手动执行了一遍onChange
   2. 支持设置dictConfig，当后端某些业务接口不方便设置id name属性
   3. 封装disabledValues、hiddenValues，对下拉数据的展示进行处理
   4. preHandleDictData，就是在渲染下拉列表之前，对数据最后一次处理
   5. 支持远程获取数据，初始化获取，以及重要props改变时重新获取下拉列表，并支持分页查询，利用totalRecord

4. echarts图表 资金分析，封装支持接口查询数据传入option、resize、tooltip格式化展示、对后端数据格式进行预处理，原理是使用canvas画图

**数据请求**

使用Request、fetch封装各种网络请求API，统一api调用，入参规范格式，增加loading

增加工具：easyApi、增加请求装饰器 response/retry/norepeat

**额外功能**

excel解析，引入xlsx，封装解析、下载方法。解析过程使用promise封装，按照交易系统要求，处理日期列、表头列、不解析隐藏的sheet

大数运算，引入bignumber.js，当涉及到金额类的四则运算时，为了防止精度丢失，提供专门的工具函数

### 模块打包工具

1、预编译基础库：使用DllPlugin和DllReferencePlugin将react-dom、mobx等基础库提前打包

2、热更新：使用express创建web server，配置webpackMiddleware中间件实现热更新

3、不同配置入口：提供start、dist入口，支持本地开发模式，运行服务器和代理；以及生产打包配置

**预编译基础库**

在打包之前，执行predist，预编译一些依赖，比如react、react-dom、mobx等

1、单独的预编译文件的webpack配置文件，配置入口：将多个要做成dll的库全放进来；配置出口：一定要设置library属性，将打包好的结果暴露在全局；配置plugin：设置打包后dll文件名和manifest文件所在地

2、在webpack.base.js中进行插件的配置，使用DllReferencePlugin指定manifest文件的位置即可

**热更新**：原理见下面

使用express创建web server，配置webpackMiddleware中间件实现热更新

WDM将webpack输出的文件传输给服务器，适用于灵活的定制场景。

1. 安装 `npm i express webpack-dev-middleware -D`

2. 新建`server.js`

   ```javascript
   const express = require('express');
   const webpack = require('webpack');
   const webpackDevMiddleware = require('webpack-dev-middleware');
   const config = require('./webpack.config.js');
   
   const app = express();
   const compiler = webpack(config);
   
   app.use(webpackDevMiddleware(compiler, {
     publicPath: '/'
   }));
   
   app.listen(3000, function() {
     console.log('http://localhost:3000');
   });
   ```

注意：如果要使用middleware，必须使用`html-webpack-plugin`插件，否则html文件无法正确的输出到express服务器的根目录

**不同配置入口**

### websocket实际使用

应用：推送指令信息的改动-修改、撤销、执行等，客户端接收，改动页面数据。

设计：

1. 用户登录后初始化一个封装好的websocket实例，内部已经监听了……
2. 

### 前端监控

sentry

### 详细介绍MsgCenter

设计：

1. 增加一个类属性topicMap，使用一个map类型的变量存储事件和回调的关系

2. 增加 publish subscribe unsubscribe 方法，分别用来实现发布、订阅、取消订阅、重置功能
   1. subscribe订阅方法：订阅一个事件，并带上回调。此时需要将回调函数保存在topicMap对应的key中
   2. publish发布方法：发布一个事件，并带上发布的data。需要从topicMap中取出事件对应的value，也就是订阅的时候存储的回调。并一一执行
   3. unsubscribe方法：传入token，从topicMap取出对应的回调，并删除

使用：

整个项目实例化一个MsgCenter，一般在componentDidMount中订阅事件，卸载时取消订阅

### 遇到的问题

问题：项目中出现的常量，比如指令状态、交易方向等，多个地方用到，同一个项目又有很多人开发。存在 使用范围广、变更后又难以维护的问题。

分析：

1. 项目使用常量 从常量类型区分，可以分为静态常量（基本不会有改动或很少改动）、动态常量。静态变量使用前端页面维护，可以导出文件，供前端、后端使用。动态类型使用单独的字典服务 提供接口访问
2. 每次更新字典文件都需要导出，并覆盖已有的文件内容， 不得手动更改该文件内容
3. 业务中用到的字典相关常量，必须使用字典，不能使用魔数

设计：

1. 字典 设计，包括：字典key、名称、类型、字典值、翻译、英文值。字典key是唯一的，可以有多个字典值。

   比如业务属性中交易方向，包括正回购、逆回购。那么设计字典key是trade_type，字典值sell_repo、reverse_repo

2. 根据使用场景，设计DICTDATA、DICT两种常量

使用场景：表单下拉框、表格列翻译、业务逻辑使用常量值判断、页面展示要使用常量翻译后的值

开发替换

自测

### 为什么使用mobx状态管理

**Mobx VS Redux**

实际的业务场景，毕竟选择任何一个状态管理库都是为了解决实际问题。我们的业务场景特点:


1. 单页 SPA 架构，页面切换通过 history 路由来实现
2. 多标签页，类似于浏览器的标签页，一个标签页就是一个菜单
3. 基于约定式路由，每一个页面都是一个组件，每一个组件都可以独立工作，并不依赖其它组件
4. 系统复杂，页面很多，但页面与页面之间基本上没有关系，也不存在数据共享的问题
5. 系统按照不同模块拆分，不同人各负责一个或多个模块，每个人的技术能力、业务能力都有差别
6. 没有数据缓存的需求，也即不支持浏览器的回退功能

Redux 有个特点就是集中式的状态管理，按照约定的目录编写业务逻辑，由于是集中式的数据流管理，数据都维护在同一个地方，所以要做回退的功能就比较容易，这个特性非常好。但实际的业务场景， Redux 并不能很好解决问题，主要有几点：

1. 每一个页面组件都是独立的，状态数据也是隔离的，而 Redux 是集中式的状态管理，不便于做数据隔离（虽然也是有办法的）
2. 多标签页的场景下，在标签页之间切换时不能让页面组件重新渲染，Redux 是单一 store 模式，意味着每次切换都要重新加载页面数据，难度和风险比较大；
3. 我们有些业务场景非常复杂，页面中的交互很多，每次改变数据如果都走 Redux 的数据流，会比较繁琐。

而 Mobx 能相对很好的解决以上问题

1. Mobx 是多 store 模式，意味着每一个组件都可以拥有自己的 store,管理自己的数据，而不会影响到其它的组件。
2. 在多标签页的模式下，每一个页面都是独立的，利用 Mobx 可以很好地做到数据隔离
3. Mobx 相对简单，特别是数据观察这一块，能够比较直观的反映数据的变化(有点像双向数据绑定），上手比较方便
4. 组件的复用比较简单，当我们开发一个公共业务组件时，理想是一个无状态组件（SFC），但是现实是很难做到的，总会有一些副作用（例如接口调用）；如果交互比较复杂，还需要引入状态管理，Mobx是多store模式的，意味着业务组件内部完全可以有自己的状态管理，当组件复用时，不用关心组件的内部实现，而Redux是统一store，要做到这一点比较难。

**Mobx vs Hooks**

我认为 Mobx 是 Hooks 的一种补充，如果交互比较简单，推荐 Hooks 就可以解决问题了，如果交互比较复杂，还是选择专业的状态管理库靠谱些（但并不代表 Hooks 不能用在复杂的场景中）。

### 低代码平台

### 前端开发规范

1. 任务分配：合理安排任务，尽量减少出现多个人任务交叉的情况，尽量保证独立开发
2. 代码书写：
   1. 使用eslint配置项，规定代码语法，例如：回调函数嵌套禁止超过 3 层、switch语句最后必须有default等
   2. 使用pretieer配置项，规范代码风格，例如：使用2个空格缩进、行尾需要有分号等
3. 代码提交：
   1. git提交遵循规范，例如根据提交内容的不同添加类型，commit描述与提交内容一致，没有特殊情况下，每次merge请求仅包含一个commit
   2. git 增加`precommit`校验，针对提交的文件类型，自动根据 eslint、pretieer格式化文件

### 性能优化

https://segmentfault.com/a/1190000022205291

1. js优化

   1. 相同作用情况下，使用性能较低的遍历方法，尽量不使用for-in

   2. 使用防抖 和 节流。防抖函数的应用场景：按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次

      **节流函数的适⽤场景：**

      - 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动
      - 缩放场景：监控浏览器resize
      - 动画场景：避免短时间内多次触发动画引起性能问题

   3. 使用事件委托。利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

2. CSS

   1. 使用 flexbox 而不是较早的布局模型
   2. 降低 CSS 选择器的复杂性：浏览器读取选择器，遵循的原则是从选择器的右边到左边读取
   3. 尽可能利用 CSS3 效果代替图片。有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一

3. html文件： CSS 放在文件头部，JavaScript 文件放在底部。

4. react：使用React.PureComponent、React.memo、React.lazy

5. webpack

   1.  压缩文件
   2.  **优化打包体积**
       1. `mini-css-extract-plugin`是用于将css提取为独立的文件的插件，对每个包含css的js文件都会创建一个css文件，支持按需加载css
       2. 使用ignorePlugin插件来忽略掉一些占空间的文件，比如 `new webpack.IgnorePlugin(/\.\/locale/, /moment/)`
       3. scope hoisting分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中去，但前提是不能造成代码冗余。因此只有那些被引用了一次的代码才能被合并。
       4. tree shaking   Production模式会自动打开
   3.  添加缓存.cache；使用缓存 cache 字段 和 babel-cache `cacheDirectory: true`
   4.  优化打包速度。优化babel-loader，使用include exclude ；使用thread-loader多线程；使用dllPlugin 提前打包库

6. chrome

   1. 合理使用浏览器缓存
   2. 减少浏览器重排重绘：避免使用table、使用class集中改、display none、transform改位置。chrome

7. 其他

   1. 懒加载 当图片出现在可视区域时，获取图片的真实地址并赋值给图片 js-summary
   2. 静态资源使用 CDN

## js

### fetch的优缺点

**fetch的优缺点：**

优点：

- 语法简洁，更加语义化
- 基于标准 Promise 实现，支持 async/await
- 更加底层，提供的API丰富（request, response）
- 脱离了XHR，是ES规范里新的实现方式

缺点：

- fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
- fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
- fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
- fetch没有办法原生监测请求的进度，而XHR可以

**ajax的优缺点：**

优点：可以无需刷新页面而与服务器端进行通信；允许根据用户事件来更新部分页面内容

缺点：没有浏览历史，不能回退；存在跨域问题(同源)；SEO不友好

详细介绍fetch请求:

使用了ES6中的promise对象。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。

```javascript
btn.onclick = function() {
    fetch('http://127.0.0.1:8000/fetch-server', {
        method: 'POST',
        // 请求头
        headers: {
            name: 'Belle',
        },
        // 请求体
        body: 'username=admin&password=admin',
    }).then(response => {
        // response本身并没有返回数据，必须调用.json()方法
        return response.json();
    }).then(response => {
        // response.json()是promise实例对象，通过链式then获取真正的返回值
        console.log('response', response);
    });
}
```

### 对this的理解

运行时绑定的引用

| 调用方式     | this指向                                            |
| ------------ | --------------------------------------------------- |
| 普通函数调用 | window  global(node)  严格模式下，this指向undefined |
| 构造函数调用 | 实例对象，原型对象里面的方法也指向实例对象          |
| 对象方法调用 | 该方法所属对象                                      |
| 事件绑定方法 | 绑定事件对象                                        |
| 定时器函数   | window                                              |
| 立即执行函数 | window                                              |
| 箭头函数     | 运行时的执行上下文                                  |

call、apply、bind改变this指向

### iframe的优缺点

 iframe的优点：

1. iframe能够原封不动地把嵌入的网页展现出来。
2. 完全隔离了`css`和`js`，避免了各个系统之间的样式和`js`污染
3. 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
4. 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
5. 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。

iframe的缺点：

1. iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。会阻塞页面的加载。每次点击都需要重新加载，虽然可以采用 `display:none` 来做缓存，但是页面缓存过多会导致电脑卡顿

2. 弹窗及遮罩层问题。弹窗只能在 `iframe` 范围内垂直水平居中，没法在整个页面垂直水平居中。通过与框架页面消息同步解决，将弹窗消息发送给主页面，主页面来弹窗，对原项目改动大且影响原项目的使用。

3. `iframe` 内的 `表格` 无法全屏。当页面在 `iframe` 里面时，全屏会报错，且 `dom` 结构错乱。

4. 多个子应用需要维护多套信息

5. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中

   chrome

```html
<iframe src="http://www.runoob.com"></iframe>
```

| 属性   | 解释     |
| ------ | -------- |
| hegith | 高度     |
| width  | 宽度     |
| src    | 资源路径 |

### 其他的微应用框架

https://juejin.cn/post/6844904185910018062

**single-spa**

`spa` 单页应用时代，我们的页面只有 `index.html` 这一个 `html` 文件，并且这个文件里面只有一个内容标签 `<div id="app"></div>`，用来充当其他内容的容器，而其他的内容都是通过 `js` 生成的。只需要拿到子项目的上面四个标签，插入到主项目的 `HTML` 中，就可以在父项目中展现出子项目。

```html
<link href=/css/app.c8c4d97c.css rel=stylesheet>
<div id=app></div>
<script src=/js/chunk-vendors.164d8230.js> </script>
<script src=/js/app.6a6f1dda.js> </script> 
```

相对于 `iframe`，`single-spa` 让父子项目属于同一个 `document`，这样做既有好处，也有坏处。好处就是数据/文件都可以共享，公共插件共享，子项目加载就更快了，缺点是带来了 `js/css` 污染。

**qiankun**

使用 `HTML entry` ，使用起来和 `iframe` 一样简单，但是用户体验比 `iframe` 强很多。`qiankun` 请求到子项目的 `index.html` 之后，会先用正则匹配到其中的 `js/css` 相关标签，然后替换掉，它需要自己加载 `js` 并运行，然后去掉 `html/head/body` 等标签，剩下的内容原样插入到子项目的容器中。

使用 `qiankun` 的好处：

1. `qiankun` 自带 `js/css` 沙箱功能，`singles-spa` 可以解决 `css` 污染，但是需要子项目配合
2. `single-spa` 方案只支持 `JS entry` 的特点，限制了它只能支持 `vue` 、 `react` 、 `angular` 等技术开发的项目，对一些 `jQuery` 老项目则无能为力。`qiankun` 则没有限制
3. `qiankun` 支持子项目预请求功能。

`qiankun` 的 `css` 沙箱的原理是重写 `HTMLHeadElement.prototype.appendChild` 事件，记录子项目运行时新增的 `style/link` 标签，卸载子项目时移除这些标签。

`qiankun`解决`js`污染的办法是：在子系统加载之前对`window`对象做一个快照（拷贝），然后在子系统卸载的时候恢复这个快照，即可以保证每次子系统运行的时候都是一个全新的`window`对象环境。大致原理就是记录`window`对象在子系统运行期间新增、修改和删除的属性和方法，然后会在子系统卸载的时候复原这些操作。

那么如何监测`window`对象的变化呢，直接将`window`对象进行一下深拷贝，然后深度对比各个属性显然可行性不高，`qiankun`框架采用的是`ES6`新特性，`proxy`代理方法。

`qiankun`框架不好实现`keep-alive`需求，因为解决`css/js`污染的办法就是删除子系统插入的标签和劫持`window`对象，卸载时还原成子系统加载前的样子，这与`keep-alive`相悖：`keep-alive`要求保留这些，仅仅是样式上的隐藏。



### MVVM 和 MVC

https://www.cnblogs.com/ranyonsue/p/12090647.html

**MVC:** Model(模型) - View(视图) - Controller(控制器)，View传送指令到Controller，Controller完成业务逻辑后改变Model状态，Model将新的数据发送至View,用户得到反馈。所有通信都是单向的。

优点：

1、耦合性低。视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码

2、重用性高。MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型

3、可维护性高。分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。

4、部署块。使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。

缺点：

1、增加系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。

2、视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。

3、视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。

**MVVM**：Model-View-ViewModel。把`MVC`中的`Controller`改变成了`ViewModel`。`View`的变化会自动更新到`ViewModel`,`ViewModel`的变化也会自动同步到`View上`显示。开发人员不用操作DOM，只用关注业务逻辑，与MVC的主要区别，使用VM调度者实现了数据的双向绑定

优点：

1、低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。

2、可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。

3、独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计

4、可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。

缺点：

1、数据绑定也使得bug很难被调试

2、数据双向绑定不利于代码重用

3、一个大的模块中model也会很大，虽然使用方便了也很容易保证数据的一致性，但是长期持有，不释放内存就造成话费更多的内存。

### 闭包

https://segmentfault.com/a/1190000023356598

https://juejin.cn/post/6869621390849687566

闭包：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。闭包是指有权访问另一个函数作用域中变量的函数。"定义在一个函数内部的函数"。

> 作用域：根据名称查找变量的一套规则。分为三种类型：全局作用域；函数作用域；块作用域。
>
> 作用域链：当不同的作用域 圈套在一起时，就形成了作用域链。注意的是，查找方向是从内到外的。

```javascript
function foo() {
    var a = 1; // a 是一个被 foo 创建的局部变量
    function bar() { // bar 是一个内部函数，是一个闭包
        console.log(a); // 使用了父函数中声明的变量
    }
    return bar;
}
const myFoo = foo();
myFoo();
```

`foo()` 函数执行后，正常情况下 `foo()` 的整个内部作用域被销毁，占用的内存被回收。但是现在的 `foo`的内部作用域 `bar()` 还在使用，所以不会对其进行回收。bar() 依然持有对改作用域的引用，这个引用就叫做闭包。

定时器，事件监听器，`Ajax`请求，跨窗口通信，`Web Workers`或者其他异步或同步任务中，只要使用回调函数，实际上就是闭包。

**注意：**闭包容易导致内存泄漏。闭包会携带包含它的函数作用域，因此会比其他函数占用更多的内存。

**闭包用途：**

- 创建私有变量和方法。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量
- 柯里化函数：利用闭包可以把参数分成多次传参
- 实现防抖或者节流函数
- 实现缓存结果。使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包保留了这个变量对象的引用，所以这个变量对象不会被回收。

### 同源策略和跨域

https://juejin.cn/post/7112279024210018334

https://juejin.cn/post/6913541999735881741

https://juejin.cn/post/6844903767226351623#heading-15

**同源策略(same-origin-policy)**

解释：是浏览器的一种安全策略，违背同源策略就是跨域。同源：协议、域名、端口号 必须完全相同，浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。css文件的加载不受跨域限制；window.onerror方法默认情况下无法获取跨域脚本的报错详情

作用：保护浏览器的数据安全和用户的隐私安全

限制：

- Cookie、LocalStorage、sessionStorage 和 IndexDB 无法读取

- DOM和JS对象无法获得

- AJAX 请求不能发送，被浏览器拦截了 但是有三个标签是允许跨域加载资源：`<script src=XXX>` `<img src=XXX>` `<link href=XXX>`

**跨域**

违反同源策略就是跨域，指浏览器不能执行其他网站的脚本。某些情况下，可以通过各种方式，避开浏览器的安全限制。如果是协议和端口造成的跨域问题“前台”是无能为力的。

**1、JSONP**

原理：`JSONP`通过同源策略涉及不到的"漏洞"，也就是像`img`中的`src`，`link`标签的`href`，`script`的`src`都不受同源策略的限制。利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。

缺点：只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。

```javascript
// 检测用户名是否存在
app.all('/check-username', (request, response) => {
  const data = {
    exist: 1,
    msg: '用户名存在',
  };
  let str = JSON.stringify(data);
  // 返回结果
  // JSONP原理，返回函数调用
  response.end(`handle(${str})`);
});
```

**2、CORS**

CORS：W3C标准，”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

原理：浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息。服务器设置`Header[Access-Control-Allow-Origin]`HTTP响应头之后，浏览器将会允许跨域请求。不需要在客户端做任何特殊的操作，完全在服务器中进行处理。

浏览器将`CORS`请求分成两类：简单请求和非简单请求

(1)简单请求

满足以下条件，就是简单请求：

1. 请求方法是：`HEAD`、`POST`、`GET`
2. 请求头只有：`Accept`、`AcceptLanguage`、`ContentType`、`ContentLanguage`、`Last-Event-Id`

简单请求时，浏览器会直接发送跨域请求，并在请求头中携带`Origin`并赋值为当前域名，表明这是一个跨域的请求。

服务器端接到请求后，会根据自己的跨域规则，来返回验证结果。如果验证成功，则会直接返回访问的资源内容。

如果Origin指定的源，不在服务端设置的对应响应头的许可范围内，一般服务器会返回一个403 Forbidden的HTTP响应和控制台错误。

注：后端需要设置的响应头：

| CORS Header属性                          | 解释                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| Access-Control-Allow-Origin （必须）     | 表示接受哪些域名的请求(`*`为所有)                            |
| Access-Control-Allow-Methods             | 设置允许跨域请求的方法                                       |
| Access-Control-Max-Age                   | 设置在86400秒不需要再发送预校验请求                          |
| Access-Control-Expose-Headers（可选）    | 允许跨域请求包含（XMLHttpRequest只能拿到六个字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Last-Modified`、`Expires`、`Pragma` , 如果想拿到其他的需要使用该字段指定 |
| Access-Control-Allow-Credentials（可选） | 设置是否允许传Cookie （要是想传cookie，前端需要设置`xhr.withCredentials = true`，后端设置`Access-Control-Allow-Credentials: true`） |

- Access-Control-Expose-Headers的六个字段属性：
  - ① Cache-Control：通过指定首部字段 `Cache-Control` 的指令，来进行缓存操作的工作机制，多个参数之间可以使用“,”分隔
  - ② Content-Language：会告知客户端，实体主体使用的自然语言（指中文或英文等语言）；
  - ③ Content-Type：说明实体主体内对象的媒体类型
  - ④ Last-Modified：指明资源最终修改时间
  - ⑤Expires：会将资源失效日期告知客户端
  - ⑥Pragma：是HTTP/1.1 之前版本保留的历史遗留字段，仅作为与HTTP/1.0 的向后兼容而定义。

![简单请求](https://images-sally.oss-cn-beijing.aliyuncs.com/img/cors%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B.png)

(2)非简单请求

对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`

1）非简单请求的`CORS`请求会在正式通信之前进行一次预检请求。预检请求格式：

- `OPTIONS`：请求行 的请求方法为`OPTIONS`（专门用来询问的）
- `Origin`：通过预检之后的请求,会自动带上Origin字段
- `Access-Control-Request-Method`：请求的方式
- `Access-Control-Request-Header`

```javascript
OPTIONS /cors HTTP/1.1  //`"预检"`使用的请求方法是 `OPTIONS` , 表示这个请求使用来询问的
Origin: localhost:2333 
Access-Control-Request-Method: PUT // 表示使用的什么HTTP请求方法 
Access-Control-Request-Headers: X-Custom-Header // 表示浏览器发送的自定义字段 
Host: localhost:2332 
Accept-Language: zh-CN,zh;q=0.9 
Connection: keep-alive 
User-Agent: Mozilla/5.0...
```

2）服务器收到预检请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

预检的响应头:

```javascript
HTTP/1.1 200 OK 
Date: Mon, 01 Dec 2008 01:15:39 GMT 
Server: Apache/2.0.61 (Unix) 
Access-Control-Allow-Origin: http://localhost:2332 // 表示http://localhost:2332可以访问数据 
Access-Control-Allow-Methods: GET, POST, PUT 
Access-Control-Allow-Headers: X-Custom-Header 
Content-Type: text/html; charset=utf-8 
Content-Encoding: gzip Content-Length: 0 
Keep-Alive: timeout=2, max=100 
Connection: Keep-Alive 
Content-Type: text/plain
```

3）通过预检后，才会进行正式的请求，浏览器接下来的每次请求就类似于简单请求了

- 如果预检请求验证失败，则会返回403状态，浏览器不会发送真正的跨域请求。

- 通过了预检请求后,请求的时候就会跟简单请求一样,会有一个`Origin`头信息字段。
- 通过预检之后的,浏览器发出正式请求

```javascript
PUT /cors HTTP/1.1 
Origin: http://api.bob.com // 通过预检之后的请求,会自动带上Origin字段 
Host: api.alice.com X-Custom-Header: value 
Accept-Language: en-US 
Connection: keep-alive 
User-Agent: Mozilla/5.0...
```

3、proxy代理

此处介绍的使用devServer解决跨域，其实原理就是http proxy

将所有ajax请求发送给devServer服务器，再由devServer服务器做一次转发，发送给数据接口服务器

由于ajax请求是发送给devServer服务器的，不存在跨域。

注：所谓跨域，是指浏览器向客户端发请求造成的，而devServer由于是用node平台发送的http请求，自然也不涉及到跨域问题。

webpack-dev-server解决办法，在devServer配置

```javascript
devServer: {
    proxy: {
      // 当前端请求/api地址时，会将请求转发到http://localhost:8000
      "/api": {
        target: "http://localhost:8000",
        pathRewrite: {"^/api" : ""}
      }
    },
  },
```

```java
// 使用时
axios.get('/api/cors-server').then(result => console.log(result));
```

4、window.postMessage(message, targetOrigin, [transfer])

5、websocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据

HTTP协议通信只能客户端发起，只能是客户端向服务器发出请求，服务器返回查询结果，HTTP协议不能服务器主动向客户端推送消息。

WebSocket协议，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话

特点：

（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL

```
ws://example.com:80/some/path
```

### commonJs和es6模块的区别

1、CommonJS模块输出的是一个值的浅拷贝，ES6 模块输出的是值的引用

CommonJS输出的是值的拷贝，一旦输出了某个值，如果模块内部后续的变化，影响不了外部对这个值的使用

ES6模块运行机制完全不一样，JS 引擎对脚本静态分析的时候，遇到import`，就会生成一个只读引用。等到脚本真正执行的时候，再根据这个只读引用，到被加载的那个模块里去取值。

2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口

CommonJS其实加载的是一个对象，这个对象只有在脚本运行时才会生成，而且只会生成一次。ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成，这样我们就可以使用各种工具对JS模块进行依赖分析，优化代码

3、循环加载

CommonJS 模块遇到循环加载时，输出的是当前已经执行那部分的值，而不是代码全部执行后的值。

```javascript
// a.js
exports.done = false;
var b = require('./b.js');
console.log('在 a.js 之中，b.done = %j', b.done);
exports.done = true;
console.log('a.js 执行完毕');
```

```javascript
// b.js
exports.done = false;
var a = require('./a.js'); // 只能取到第一个done false
console.log('在 b.js 之中，a.done = %j', a.done);
exports.done = true;
console.log('b.js 执行完毕');
```

ES6 模块是动态引用，如果使用`import`加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值

4、在ES6模块顶层，`this`指向`undefined`；而CommonJS模块的顶层的`this`指向当前模块

5、在ES6模块中可以直接加载CommonJS模块，但是只能整体加载，不能加载单一的输出项。Node.js 对 ES6 模块的处理就比较麻烦了，因为它有自己的 CommonJS 模块规范，与 ES6 模块格式是不兼容的。

6、因为CommonJS的`require`语法是同步的，所以就导致了CommonJS模块规范只适合用在服务端，而ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用 

7、commonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层

8、CommonJs 是单个值导出，ES6 Module可以导出多个

### js和css文件下载阻塞是否阻塞DOM树合成

当服务器接收html页面的第一批数据时，DOM解析器就开始工作了。

1. 在解析过程中，如果遇到js脚本，会先执行，然后继续往下解析。
2. 如果遇到js文件，会先下载js文件，并执行，然后继续往下解析。

### 箭头函数和普通函数的区别

1. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数
3. 箭头函数不具有prototype原型对象。没有`prototype`自然也不能通过super来访问原型的属性，所以箭头函数也是没有super的
4. 不能被 new 调用，箭头函数内部没有 [[Construct]] 方法，因此不能当作构造函数使用，使用 new 调用箭头函数会抛出错误
4. 箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply() **vs** 在普通函数中，this总是指向调用它的对象，如果用作构造函数，this指向创建的对象实例; 在严格模式下的函数调用下，this指向undefined;如果该函数是一个对象的方法，则它的this指针指向这个对象
6. 普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数
7. 每一个普通函数调用后都具有一个arguments对象，用来存储实际传递的参数。但是箭头函数并没有此对象。

### es6新特性

https://juejin.cn/post/6952406023269253157

1. 块级作用域：const、let，不具备变量提升的特性，形成暂时性死区，提前访问变量会报错
2. 数据结构：`symbol`、`map`、`set`
3. promise
4. 模版字符串
5. 箭头函数
6. class类，的声明不会提升，如果你要使用某个 `Class`，必须在使用之前定义它。
7. 参数默认值
8. Rest 操作符 `...`
9. 对象数组解构
10. 字符串的扩展方法 includes()  startsWith()  endsWith()

### js和ts

`TypeScript` 是 `JavaScript` 的类型的超集，支持`ES6`语法，支持面向对象编程的概念，如类、接口、继承、泛型等。是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误。同时扩展了` JavaScript` 的语法，所以任何现有的` JavaScript` 程序可以不加改变的在 `TypeScript` 下工作。为了保证兼容性，`typescript`在编译阶段需要编译器编译成纯`Javascript`来运行。

typescript的特性主要有如下：

- 基本类型增加：

  |    类型    |       例子        |                  描述                  |
  | :--------: | :---------------: | :------------------------------------: |
  |    any     |         *         |                任意类型                |
  |  unknown   |         *         |             类型安全的any              |
  |    void    | 空值（undefined） |         没有值（或undefined）          |
  |   never    |      没有值       |              不能是任何值              |
  | tuple 元组 |       [4,5]       | 元素，TS新增类型，固定长度不同类型数组 |
  | enum 枚举  |    enum{A, B}     |           枚举，TS中新增类型           |

- 类型
  - 类型标注和编译时类型检查 ：在编译时标注变量类型
  - 类型推断：ts中没有批注变量类型会自动推断变量的类型
  - 类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除
- 接口：ts中用接口来定义对象类型
- 泛型：写代码时使用一些以后才指定的类型。在定义函数、接口或类的时候，不预先指定具体的类型，使用时再去指定类型的一种特性。可以把泛型理解为代表类型的参数
- namespace：名字只在该区域内有效，其他区域可重复使用该名字而不冲突

|          | js       | ts               |
| -------- | -------- | ---------------- |
| 语言     | 脚本语言 | 面向对象编程语言 |
| 学习难度 | 灵活     |                  |
| 类型     | 弱类型   | 强类型           |
| 扩展名   | .js      | .ts              |
| 耗时     | 更快     | 需要先解析成js   |
| 可选参数 | 不支持   | 支持             |
| 静态类型 | 不支持   | 支持             |

**为什么要用 TypeScript ？**

- TS 在开发时就能给出编译错误， 而 JS 错误则需要在运行时才能暴露。
- 作为强类型语言，你可以明确知道数据的类型。代码可读性极强，几乎每个人都能理解。

### 执行上下文和调用栈

执行上下文的类型分为三种：

- 全局执行上下文：只有一个，浏览器中的全局对象就是 `window`对象，`this` 指向这个全局对象
- 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文
- Eval 函数执行上下文： 指的是运行在 `eval` 函数中的代码，很少用而且不建议使用



调用栈：当`Javascript`引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中

每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中

引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文

### 单页面应用和微前端

**单页面应用：**

优点：

- 良好的交互体验。内容的改变不需要重新加载整个页面，没有页面之间的切换，就不会出现“白屏现象” 和闪烁
- 同一基础依赖，可以统一维护

缺点：

- 项⽬太⼤，架构升级⻛险⾮常⾼ 
- 模块间存在藕合，容易导致公⽤资源、代码冲突，各模块开发⼈员难以考虑不相关模块 兼容性

**微前端：**

优点：

- 应用自治。只需要遵循统一的接口规范或者框架，以便于系统集成到一起，相互之间是不存在依赖关系的。

- 技术栈无关。你可以使用 Angular 的同时，又可以使用 React 和 Vue。

缺点：

- 应用的拆分基础依赖于基础设施的构建，一旦大量应用依赖于同一基础设施，那么维护变成了一个挑战。
- 拆分的粒度越小，便意味着架构变得复杂、维护成本变高。
- 技术栈一旦多样化，便意味着技术栈混乱

## react

### react生命周期

### 对diff的理解

https://juejin.cn/post/7075930149350277151

`React`引入`Virtual DOM`的概念，极大地避免无效的`Dom`操作，使我们的页面的构建效率有极大的提升。而`diff`算法就是更高效地通过对比新旧`Virtual DOM`来找出真正的`Dom`变化之处。

传统diff算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，`react`将算法进行一个优化，复杂度`O(n)`：

1. 只对同级比较，跨层级的dom不会进行复用
2. 不同类型节点生成的dom树不同，此时会直接销毁老节点及子孙节点，并新建节点
3. 可以通过key来对元素diff的过程提供复用的线索

单节点diff：从同层级的老`fiber`节点中找出`key`值和`type`都相等的老节点，如果该老fiber节点存在，则复用他，然后删除剩余的节点，否则重新生成一个新的`fiber`节点（这也就意味着以这个节点为根的子树需要重新生成）。

多节点diff主要可以分为两轮循环，第一轮循环主要是新旧节点同位置对比，找到第一个无法复用的节点位置后，以最后一个可复用旧节点的位置作为后续作为判断节点是否需要重新插入的基准位置值（该值后续可能会变），然后跳出循环。

如果经历了第一轮循环后，会存在三种情况：

1. 新节点已经遍历完成：删除剩余的老节点，结束多节点diff
2. 老节点遍历完成，新节点还为遍历完，将剩余的新节点逐一创建`fiber`节点，并标记为重新插入，然后结束diff
3. 老节点、新节点都没遍历完，这种情况就比较复杂，需要将剩余的老节点放入一个map中，然后开启第二轮循环；

第二轮循环：

本轮循环是遍历剩余的新节点，遍历时，新节点都从map中寻找有没有自己能复用的老节点（key和type相同即可复用），如果map中存在就复用，然后将该老节点从map中移除，否则就重新生成。如果老节点被复用了，就会将该老节点原来所在的位置和第一轮循环确定的基准位置值比较，老节点的位置在基准位置值的左边时，说明复用该老节点的新节点需要重新插入，基准位置值不变；老节点的位置在基准位置值的右边时，说明复用该老节点的新节点无须移动，但是基准位置值需要更新为老节点的位置。

第二轮循环结束了，只需要将map中剩余的老节点标记为删除即可。

### hook相比类组件

相同点：都可以接收props返回react元素

不同点：

1、类组件需要继承 class，函数组件不需要

2、类组件可以访问生命周期方法，函数组件不能，函数数据是通过hooks实现生命周期的方法

3、类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，理解困难，而函数组件不可以

4、简单组件使用函数组件更轻量级

5、函数组件会捕获 render 内部的状态，类组件状态和渲染是隔离的

6、开类组件内部的逻辑难以实现拆分和复用。（比如高阶组件、Render Props 等可以实现）

7、编程思想：类组件需要创建实例，面向对象，函数组件不需要创建实例，接收输入，返回输出，函数式编程

### hook只能顶层调用

hook只能在组件顶层使用，不要在循环、条件或嵌套函数中调用，在任何 return 之前调用，原因：

https://blog.csdn.net/weixin_43484007/article/details/124354511

https://blog.csdn.net/gtLBTNq9mr3/article/details/119880486

```javascript
// 当前正在运行的组件
let currentComponent
// 当前 hook 的全局索引
let currentIndex
// 第一次调用 currentIndex 为 0
useState('first') 
// 第二次调用 currentIndex 为 1
useState('second')
```

每次 Hook 的调用都对应一个全局的 index 索引，通过这个索引去当前运行组件 currentComponent 上的 _hooks 数组中查找保存的值，也就是 Hook 返回的 [state, useState]。

原理：

```react
let hookStates = [];
let hookIndex = 0;
function useState(initialState){
  hookStates[hookIndex]=hookStates[hookIndex] || initialState;
  let currentIndex = hookIndex;
  function setState(newState){
    hookStates[currentIndex] = newState;
    render();
  }
  return [hookStates[hookIndex++], setState];
} 
 
 
function useEffect(callback,dependencies){
  if(hookStates[hookIndex]){
      let lastDeps = hookStates[hookIndex];
      let same = dependencies.every((item,index)=>item === lastDeps[index]);
      if(same){
        hookIndex++;
      }else{
        hookStates[hookIndex++] = dependencies;
         setTimeout(callback);
      }
  }else{
     hookStates[hookIndex++] = dependencies;
     setTimeout(callback);
  }
```

### react-loadable与React.lazy的区别

react-loadable支持服务端渲染

目前查到的文档，都是推荐不使用react-loadable，因为它不再维护了，并且应该尽量减少项目对第三方的依赖。

React.lazy原理：通过调用动态的`import()`加载一个函数，此时会返回一个`Promise`，并解析(`resolve`)为一个带有包含React组件的默认导出的模块。

React.lazy加载的组件只能在<React.Suspense>组件下使用。React.Suspense可以优化懒加载前的交互，`fallback` 属性接受组件加载过程中想展示的 React 元素，可以将 `Suspense` 组件置于懒加载组件之上的任何位置。

### react和vue的区别

相同点
1）都有组件化开发和Virtual DOM。
2）都支持props进行父子组件间的数据通信。
3）都支持数据驱动视图，不直接操作真是DOM,更新状态数据界面就自动更新。
4）都支持服务端渲染。
5）都有支持native的方案，React的React Native,Vue的Weex。

不同点
1）数据绑定：vue实现了数据的双向绑定，React数据流动是单向的。
2）组件写法不一样，React推荐的做法是JSX，也就是把HTML和CSS全都写进JavaScript了，即'all in js',Vue推荐的做法是webpack+vue+loader的单文件组件格式，即html,css,js写在同一个文件。
3）state对象在react应用中不可变的，需要使用setState方法更新状态，在vue中，state对象不是必须的,数据由data属性在vue对象中管理。
4)virtual DOM不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件数，而对于React而言，每当应用的状态被改变时，全部组件都会重新渲染，所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制。
5）React严格上只针对MVC的view层，Vue则是MVVM模式。

### react的理解

React，用于构建用户界面的 JavaScript 库

遵循组件设计模式和函数式编程概念， `render()` 的方法或者函数组件`return`，接收输入的数据并返回需要展示的内容

使用虚拟 `DOM` 来有效地操作 `DOM`

单向数据流：遵循从高阶组件到低阶组件的单向数据流

组件化：将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面

`React` 特性有很多，如：

- JSX 语法
- 单向数据绑定
- 虚拟 DOM
- 声明式编程
- Component：一切皆组件，将界面成了各个独立的小块，每一个块就是组件

`React`存在的优势：

- 高效灵活
- 声明式的设计，简单使用
- 组件式开发，提高代码复用率
- 单向响应的数据流会比双向绑定的更安全，速度更快

### 虚拟dom的理解

前端性能优化的一个秘诀就是尽可能少地操作DOM。虚拟DOM使得无须手动操作DOM,一方面是因为手动操作DOM无法保证程序性能,多人协作的项目中如果review不严格,可能会有开发者写出性能较低的代码,另一方面更重要的是省略手动DOM操作可以大大提高开发效率.

Virtual DOM创建：Virtual DOM是对真实DOM的抽象。没有真实DOM那么多的属性，虚拟DOM就是一个普通的JavaScript对象，包含了`tag`、`props`、`children`三个属性。

真实 `DOM` 的优势：

- 易用

缺点：

- 效率低，解析速度慢，内存占用量过高
- 性能差：频繁操作真实 DOM，易于导致重绘与回流

使用虚拟 `DOM` 的优势如下：

- 简单方便：如果使用手动操作真实 `DOM` 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难
- 性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能
- 跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行

缺点：

- 在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化
- 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢

### 你能用HOC做什么

1. 代码重用，逻辑和引导抽象

2. props 控制，渲染劫持

3. 状态抽象和控制

## 浏览器

### 浏览器里从输入URL到页面展示

1. 用户输入，地址栏判断输入的关键字是搜索内容还是请求URL

   - 搜索 内容：使用默认的搜索引擎，合成新的带搜索关键字的URL
   - 请求URL：根据规则，加上协议，合成完整的URL

   > 用户键入回车后，在浏览器继续后续流程之前，可以通过beforeunload事件取消导航。比如执行数据清理或询问用户是否要离开当前页面

2. URL请求过程。浏览器进程通过IPC把URL请求发送到网络进程，网络进程接收到URL请求后，发起真正的URL请求流程。

   1. 网络进程查找本地缓存是否缓存了该资源。若有缓存资源并且没有过期，则直接返回资源给浏览器进程；若缓存中没有资源或资源过期，则进入网络请求。

   2. 网络进程DNS解析，获取请求域名的IP。然后与服务器建立TCP连接。

   3. 当建立`tcp`连接之后，就可以在这基础上进行通信，浏览器发送 `http` 请求到目标服务器。

   4. 服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。

      - 重定向

      - 响应数据类型处理：content-type: text/html  text/plain application/json
   
   5. 准备渲染进程。浏览器进程将网络进程接收到的html数据提交给渲染进程
   
      > same-site：根域名+协议都相同 `https://www.geekbang.org:8080`
      > `https://time.geekbang.org` `https://www.geekbang.org` 
      >
      > Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程
   
      1. 当浏览器进程接收到网络进程的响应头数据后，向渲染进程发起“提交文档”的消息；
      2. 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
      3. 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
      4. 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

   6. 渲染阶段。
   
      1. DOM生成：渲染进程将html转换为 DOM 树结构
      2. 样式计算：渲染引擎将CSS转化为styleSheets。根据 CSS 样式表，计算DOM 树所有节点的样式
      3. 布局：计算 DOM 元素的布局信息，使其都保存在布局树中
      4. 对布局树进行分层，并生成分层树排列
      5. 为每个图层生成绘制列表，并将其提交到*合成线程*
      6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
      7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程
      8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### CDN

内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。

![cdn工作原理](https://images-sally.oss-cn-beijing.aliyuncs.com/img/cdn%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png)

假设通过CDN加速的域名为`www.a.com`，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：

1. 当终端用户（北京）向`www.a.com`下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。
2. LDNS检查缓存中是否有`www.a.com`的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。
3. 当授权DNS解析`www.a.com`时，返回域名CNAME `www.a.tbcdn.com`对应IP地址。
4. 域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。
5. LDNS获取DNS返回的解析IP地址。
6. 用户获取解析IP地址。
7. 用户向获取的IP地址发起对该资源的访问请求。

### 浏览器兼容性问题

各浏览器使用了不同的内核，因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一。

浏览器内核与前缀的对应关系如下：

| 内核    | 主要代表的浏览器 | 前缀    |
| ------- | ---------------- | ------- |
| Trident | IE浏览器         | -ms     |
| Gecko   | Firefox          | -moz    |
| Presto  | Opera            | -o      |
| Webkit  | Chrome和Safari   | -webkit |

**css兼容：**

1、不同浏览器的标签默认的margin和padding不同

```css
{  margin:0; padding:0; }
```

2、在IE6中，当为一个向左浮动的元素设置左外边距时，这个外边距将会是设置值的2倍。对于一个浮动元素来说设置display：inline没有任何意义。但是该属性可以解决IE6的双倍边距问题

```css
display:inline；
```

3、标签最低高度设置min-height不兼容问题

```css
{
  min-height: 200px;
  height: auto!important;
  height: 200px;
  overflow: visible;
}
```

4、opacity是css3里的属性，只有部分浏览器兼容

```css
{
    //使用各个浏览器的私有属性以支持opacity
  filter: alpha(opacity=50);/*IE*/
  -moz-opacity: 0.5;/*老版Mozilla*/
  -khtml-opacity: 0.5;/*老版Safari*/ 
  opacity: 0.5;
}
```

5、清除浮动

```css
.clearfix::after {
         content: "";
        display: table;
        clear: both;
    }
    
    .clearfix {
        *zoom: 1;
    }
```

6、IE6下图片元素img默认有间距

> 图片底部间隙原因：图片默认和基线对其，解决：vertical-align:middle | top| bottom 或 display: block

水平间隙原因：img元素之间的换行符会被当成空格处理

```css
img{ float:left; }
```

7、overflow：auto; ＋ position:relative 只出现在IE6和IE7中，有两个块级元素，父元素设置了overflow：auto;子元素设置了position:relative;且高度大于父元素，在IE6-7中子元素不会被隐藏而是溢出。

解决：给父元素也设置position:relative;

```html
<div style="overflow:auto;position:relative">
    <div style="position:relative"></div>
</div>
```

8、图片在IE下缩放有时会影响其质量

```css
img{ -mg-interpolation-mode:bicubic;}
```

9、IE6下png图片的透明bug，使用透明图片,使用png24或png32图片在IE6下面显示图片会有一层淡蓝色的背景。

```css
.img{

background:url('http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png');

_background:0;

_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png',sizingMethod='scale');

}

img{filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png',sizingMethod='scale');}

或

<imgsrc="test.png" width="247" height="216"style="filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png',sizingMethod='scale');" alt="" />
```

10、`<iframe>`透明背景bug。在IE浏览器中，`<iframe>`框架不会自动把背景设为透明

解决方案：

```js
<iframesrc="content.html"allowTransparency="true"></iframe>
复制代码
```

在iframe调用的content.html页面中设置

```js
body{background-color: transparent;}
```

11、IE8 以下版本不支持 html5 语义化标签，在head中 引入 html5shiv 插件包即可解决 IE 8 不识别 html5 语义化标签的问题

```html
<script src="html5shiv.js"></script>
```

**js兼容：**

1、获取节点

| 获取                                       | 兼容                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| ` getElementsByName()`                     | 在IE和Opera中， getElementsByName() 方法还会返回那些id为指定值的元素 |
| ` document.getElementsByClassName(‘类名’)` | ie9+支持                                                     |
| `document.querySelector(‘选择器’);`        | ie8+支持                                                     |
|                                            |                                                              |

2、`innerText和 innerHTML`

innerHTML是非标准属性(非w3c标准),但是所有的浏览器都支持（关于w3c标准，在其他文章里有提及到）

innerText属性存在兼容性问题,早期的火狐浏览器不支持该属性,使用textContent替代

3、`firstElementChild和lastElementChild` 获取子元素的第一个节点和最后一个节点，IE9+支持

解决： `children(0)` 返回第1个

4、`addEventListener（）` IE9以上支持，IE9以下使用`attchEvent()`代替

```js
var  helper = {}

 //绑定事件
 helper.on = function(target, type, handler) {
     if(target.addEventListener) {
         target.addEventListener(type, handler, false);
     } else {
         target.attachEvent("on" + type,
             function(event) {
                 return handler.call(target, event);
             }, false);
     }
 };

 //取消事件监听
 helper.remove = function(target, type, handler) {
     if(target.removeEventListener) {
         target.removeEventListener(type, handler);
     } else {
         target.detachEvent("on" + type,
         function(event) {
             return handler.call(target, event);
         }, true);
     }
 };
```

5、IE 6、7、8无法获取事件对象的兼容性写法

```javascript
box.onclick = function (e) {
  // IE 6\7\8获取事件对象使用window.event
  e = e || window.event;
}
```

6、阻止事件冒泡

`e.stopPropagation()`不支持IE 6\7\8

IE8以下使用`e.cancelBubble = true;`

```js
if (e && e.stopPropagation) {
  e.stopPropagation
} else {
  window.event.cancelBubble = true;
}
```

7、new Date()构造函数使用：'2018-07-05'是无法被各个浏览器使用new Date(str)来正确生成日期对象的。 正确的用法是'2018/07/05'.

8、获取 scrollTop 通过 document.documentElement.scrollTop 兼容非chrome浏览器

```
 var scrollTop = document.documentElement.scrollTop||document.body.scrollTop;
```

**判断浏览器：**

第一步：声明一个函数（可以判断各个浏览器和版本）

```javascript
function getBroswerAndVersion(){//该函数可以判断各种浏览器和版本，最厉害的版本
  var userAgent = navigator.userAgent; 
  var info = ""; 
  var tempArray = ""; 
  //判断浏览器版本
  var isOpera = userAgent.indexOf("Opera") > -1; //判断是否Opera浏览器
  var isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera; //判断是否IE浏览器
  var isEdge = userAgent.toLowerCase().indexOf("edge") > -1 && !isIE; //判断是否IE的Edge浏览器
  var isIE11 = (userAgent.toLowerCase().indexOf("trident") > -1 && userAgent.indexOf("rv") > -1); 
 
  if (/[Ff]irefox(\/\d+\.\d+)/.test(userAgent)) { 
    tempArray = /([Ff]irefox)\/(\d+\.\d+)/.exec(userAgent); 
    info += tempArray[1] + tempArray[2]; 
  } else if (isIE) { 
 
    var version = ""; 
    var reIE = new RegExp("MSIE (\\d+\\.\\d+);"); 
    reIE.test(userAgent); 
    var fIEVersion = parseFloat(RegExp["$1"]); 
    if (fIEVersion == 7) 
    { version = "IE7"; } 
    else if (fIEVersion == 8) 
    { version = "IE8"; } 
    else if (fIEVersion == 9) 
    { version = "IE9"; } 
    else if (fIEVersion == 10) 
    { version = "IE10"; } 
    else
    { version = "0" } 
 
    info += version; 
    } else if (isEdge) { 
    info += "Edge"; 
  } else if (isIE11) { 
    info += "IE11"; 
  } else if (/[Cc]hrome\/\d+/.test(userAgent)) { 
    tempArray = /([Cc]hrome)\/(\d+)/.exec(userAgent); 
    info += tempArray[1] + tempArray[2]; 
  } else if (/[Vv]ersion\/\d+\.\d+\.\d+(\.\d)* *[Ss]afari/.test(userAgent)) { 
    tempArray = /[Vv]ersion\/(\d+\.\d+\.\d+)(\.\d)* *([Ss]afari)/.exec(userAgent); 
    info += tempArray[3] + tempArray[1]; 
  } else if (/[Oo]pera.+[Vv]ersion\/\d+\.\d+/.test(userAgent)) { 
    tempArray = /([Oo]pera).+[Vv]ersion\/(\d+)\.\d+/.exec(userAgent); 
    info += tempArray[1] + tempArray[2]; 
  } else { 
    info += "unknown"; 
  } 
  return info;
}
```

第二步：调用函数，得到的结果再判断给用户提示即可

```js
var bro = getBroswerAndVersion();//上面第一步封装的函数，调用会得到一个返回值
if(bro=="IE5" || bro=="IE6" || bro=="IE7" || bro=="IE8" ){
   alert("浏览器版本过低!请升级至IE9以上");
}
```

### 对websocket的了解

https://juejin.cn/post/7020964728386093093

WebSocket 允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。

WebSocket 的其他特点包括：

（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

**WebSocket连接的过程是：**

1. 客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；

   ```
   GET /chat HTTP/1.1
   Host: server.example.com
   Upgrade: websocket  //告诉服务器，发起的请求要用 WebSocket 协议
   Connection: Upgrade 
   Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== // 浏览器随机生成，验证服务器是不是真的是 WebSocket 服务。
   Sec-WebSocket-Protocol: chat, superchat  // 用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议
   Sec-WebSocket-Version: 13 // 服务器所使用的 WebSocket Draft （协议版本）
   Origin: http://example.com
   ```

2. 服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据

   ```
   HTTP/1.1 101 Switching Protocols
   Upgrade: websocket // 告诉客户端即将升级的是 WebSocket 协议
   Connection: Upgrade
   Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= // 经过服务器确认，并且加密过后的 Sec-WebSocket-Key 
   Sec-WebSocket-Protocol: chat // 经过服务器确认，并且加密过后的 Sec-WebSocket-Key 
   ```

3. 客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。

**websocket断线重连：**

如何判断在线离线：

1. 当客户端第一次发送请求至服务端时会携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果不存在就存入db或者缓存中
2. 第二次客户端定时再次发送请求依旧携带唯一标识、以及时间戳，服务端到db或者缓存去查询该请求的唯一标识，如果存在就把上次的时间戳拿取出来
3. 使用当前时间戳减去上次的时间，得出的毫秒秒数判断是否大于指定的时间，若小于的话就是在线，否则就是离线

解决断线问题:  websocket发送心跳包

### websocket和http

https://www.infoq.cn/article/ujwip4vyf3xjkphimtjc

websocket和http的区别和联系：

1、WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息；HTTP是单向的，客户端发送请求，服务器发送响应

2、WebSocket是需要浏览器和服务器握手进行建立连接的，而http是浏览器发起向服务器的连接

3、协议名不同

 **联系：** WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。

默认情况下：

- 1）WebSocket 协议使用 80 端口；
- 2）若运行在 TLS 之上时，默认使用 443 端口。

客户端：

```javascript
function connectWebsocket() {
    ws = new WebSocket('ws://localhost:9000');
    // 监听连接成功
    ws.onopen = () => {
        console.log('连接服务端WebSocket成功');
        ws.send(JSON.stringify(msgData));	// send 方法给服务端发送消息
    };

    // 监听服务端消息(接收消息)
    ws.onmessage = (msg) => {
        let message = JSON.parse(msg.data);
        console.log('收到的消息：', message)
        elUl.innerHTML += `<li class="b">小秋：${message.content}</li>`;
    };

    // 监听连接失败
    ws.onerror = () => {
        console.log('连接失败，正在重连...');
        connectWebsocket();
    };

    // 监听连接关闭
    ws.onclose = () => {
    	console.log('连接关闭');
    };
};
connectWebsocket();
```

从上面可以看到 WebSocket 实例的 API 很容易理解，简单好用，通过 send() 方法可以发送消息，onmessage 事件用来接收消息，然后对消息进行处理显示在页面上。当 onerror 事件（监听连接失败）触发时，最好进行执行重连，以保持连接不中断。

服务端 Node: （这里使用 ws 库）

```javascript
const path = require('path');
const express = require('express');
const app = express();
const server = require('http').Server(app);
const WebSocket = require('ws');

const wss = new WebSocket.Server({ server: server });

wss.on('connection', (ws) => {

  // 监听客户端发来的消息
  ws.on('message', (message) => {
    console.log(wss.clients.size);
    let msgData = JSON.parse(message);
    if (msgData.type === 'open') {
      // 初始连接时标识会话
      ws.sessionId = `${msgData.fromUserId}-${msgData.toUserId}`;
    } else {
      let sessionId = `${msgData.toUserId}-${msgData.fromUserId}`;
      wss.clients.forEach(client => {
        if (client.sessionId === sessionId) {
          client.send(message);	 // 给对应的客户端连接发送消息
        }
      })
    }
  })

  // 连接关闭
  ws.on('close', () => {
    console.log('连接关闭');
  });
});
```

这样浏览器和服务端就可以愉快的发送消息了，效果如下：绿色箭头表示发出的消息，红色箭头表示收到的消息。

![image-20220627155220857](https://images-sally.oss-cn-beijing.aliyuncs.com/img/websocket-messages.png)

### ISO 七层模型

OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型

ISO 七层模型: 物理层, 数据链路层, 网络层, 传输层, 会话层, 表示层, 应用层。 http对应应用层

- 应用层：通过应用程序间的交互来完成特定的网络应用
- 表示层：使通信的应用程序能够解释交换数据的含义。主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异
- 会话层：负责建立、管理和终止表示层实体之间的通信会话。提供数据交换的定界和同步功能，包括建立检查点和恢复方案的方法
- 传输层：为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。传输层向高层屏蔽了下层数据通信的细节。主要的传输层协议是`TCP`和`UDP`
- 网络层：选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层
- 数据链路层：将网络层交下来的 `IP`数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧的数据可以分成：报头head和数据data两部分: head 标明数据发送者、接受者、数据类型，如 MAC地址；data 存储了计算机之间交互的数据
- 物理层：实现计算机节点之间比特流的透明传送。主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。主要是和硬件有关

| 协议     | 处于层级 |
| -------- | -------- |
| HTTP协议 | 应用层   |
| TCP协议  | 传输层   |
| IP协议   | 网络层   |

### 浏览器存储方式的区别

1. 传递方式不同。cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。
2. 存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
4. 作用域不同，sessionStorage在同一个页面下数据可以共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的，Cookie的作用域仅仅由domain和path决定，与协议和端口无关。
5. Web Storage 的 api 接口使用更方便，cookie的原生接口不友好，需要自己封装。

### http和https的区别

- HTTPS是HTTP协议的安全版本，HTTP的数据传输是明文，不安全，HTTPS使用SSL/TLS协议进行了加密处理，更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

### https如何安全传输

> SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议

- 混合加密：(对称加密：采用协商的密钥对数据加密。非对称加密：实现身份认证和密钥协商)
- 摘要算法：验证信息的完整性。也就是常说的散列函数、哈希函数，可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。在原文后附上它的摘要，就能够保证数据的完整性
- 数字签名：身份验证。确定消息确实是由发送方签名并发出来的。用私钥加密，公钥解密。签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的

### get和post请求的区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中

## webpack

### 对于webpack的理解

1. Webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。

2. 它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。

3. 对于不同类型的依赖，Webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。

### webpack的基本功能

1. 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等

2. 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等

3. 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载

4. 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件

5. 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器

6. 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过

7. 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。

### webpack的构建过程

Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

- `初始化参数`：从配置文件读取与合并参数，得出最终的参数
- `开始编译`：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
- `确定入口`：根据配置中的 entry 找出所有的入口文件
- `编译模块`：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
- `完成模块编译`：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
- `输出资源`：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- `输出完成`：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

在以上过程中，`Webpack` 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

简单说

- 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler
- 编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理
- 输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中

### 常见的loader

js：

1. ts-loader: 将 TypeScript 转换成 JavaScript
2. `babel-loader`：把 ES6 转换成 ES5
3. `awesome-typescript-loader`：将 TypeScript 转换成 JavaScript，性能优于 ts-loader

css：

1. css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
2. style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
3. less-loader、scss-loader：将less、scss代码转换成CSS
4. `postcss-loader`：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前

其他：

1. file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)
2. url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)
3. json-loader: 加载 JSON 文件（默认包含）
4. eslint-loader：通过 ESLint 检查 JavaScript 代码

### 常见的plugin

1. html-webpack-plugin：根据模板页面生成打包的 html 页面
2. DefinePlugin：创建全局变量
3. mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载
4. clean-webpack-plugin: 目录清理
5. copy-webpack-plugin: 拷贝文件
6. webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)

7. FriendlyErrorsWebpackPlugin：控制台显示信息优化

8. `terser-webpack-plugin`: 支持压缩 ES6 (Webpack4)

### loader和plugin的区别

`Loader` 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。

`Plugin` 就是插件，基于事件流框架 `Tapable`，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

`Loader` 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。

`Plugin` 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

### webpack提高效率的插件

`webpack-dashboard`：可以更友好的展示相关打包信息。

`webpack-merge`：提取公共配置，减少重复配置代码

`speed-measure-webpack-plugin`：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。

`size-plugin`：监控资源体积变化，尽早发现问题

`HotModuleReplacementPlugin`：模块热替换

### source-map如何使用

https://juejin.cn/post/6844904201311485966

`source map` 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。map文件只要不打开开发者工具，浏览器是不会加载的。

cheap-module-source-map, 生成的 Source Map 文件中没有列信息，但会包含 Loader 生成的 Source Map

线上环境一般有三种处理方案：

- `hidden-source-map`：会生成map文件，但浏览器不会加载source-map。可以将map文件与错误上报工具结合使用。借助第三方错误监控平台 Sentry 使用
- `nosources-source-map`：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高

模式中有三类关键词:

- inline、hidden、eval：这几个模式是互斥的，描述的是Source Map的引入方式

  inline：Source Map内容通过base64放在js文件中引入。

  hidden：代码中没有sourceMappingURL，浏览器不自动引入Source Map。

  eval：生成代码和Source Map内容混淆在一起，通过eval输出

- nosources：使用这个关键字的Source Map不包含sourcesContent，调试时只能看到文件信息和行信息，无法看到源码。

- cheap[module]

  cheap：不包含列信息，并且源码是进过loader处理过的

  cheap-module：不包含列信息，源码是开发时的代码

### webpack热更新原理

刷新一般分为两种：

- 一种是页面刷新，不保留页面状态，就是简单粗暴，直接`window.location.reload()`。
- 另一种是基于`WDS (Webpack-dev-server)`的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。

https://juejin.cn/post/6844904008432222215

`HMR`全称 `Hot Module Replacement`，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用。例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失。如果使用的是 `HMR`，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用。

步骤：

1. `webpack-dev-server`生成`compiler`实例，用来编译、输出`bundle.js`，注入了`websocket`的相关逻辑，使浏览器运行时能够与本地建立socket连接；使用`express`框架启动本地`server`，让浏览器可以请求本地的静态资源；启动`websocket`服务

2. 依赖`webpack-dev-middleware`，监听`webpack`编译完成，通过`websocket`给浏览器发布更新通知，带上构建时的 hash，让浏览器与上一次资源进行对比

   > `webpack-dev-server`只负责启动服务和前置准备工作。webpack-dev-middleware`负责所有文件相关的操作，主要是本地文件的编译和输出以及监听

3. 浏览器检查更新，利用`HotModuleReplacementPlugin`，配置了热更新以后，模块会增加一个`hot`属性，调用`module.hot.check`检查更新。浏览器向本地`webpack-dev-server`发起 `Ajax` 请求来获取更改内容(文件列表、hash)，借助获取信息继续向 WDS 发起 `jsonp` 请求获取该chunk的增量更新。使用`JSONP`原因是，获取的代码可以直接执行

4. `HotModulePlugin`决定后续更新，通过`hotupdate`找到旧模块，将新的模块添加到`moduls`中，通过`webpack_require`执行相关模块的代码

### webpack优化

1、production模式打包自带优化

- tree shaking。打包时移除JavaScript中的未引用的代码(dead-code)，它依赖于ES6模块系统中import和export的静态结构特性（import是静态必须放在顶部导入，require是动态导入，可以在不同条件下引入不同的模块）

  开发时引入一个模块后，如果只使用其中一个功能，上线打包时只会把用到的功能打包进bundle，其他没用到的功能都不会打包进来，可以实现最基础的优化。

  Production模式tree shaking会自动打开，会把没有用到的代码增加一些注释，在uglify阶段删除。

  会被tree shaking的代码：代码不会被执行，不可到达；代码执行的结果不会被用到；代码只会影响死变量（只写不读）

- scope hoisting。作用是将模块之间的关系进行结果推测，可以让Webpack打包出来的代码文件更小、运行的更快

  scope hoisting的实现原理：分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中去，但前提是不能造成代码冗余。（使用的是ModuleConcatenationPlugin）

  因此只有那些被引用了一次的代码才能被合并。

  由于scope hoisting需要分析出模块之间的依赖关系，因为源码必须采用ES6模块化语句，不然它将无法生效

- 代码压缩

  所有代码使用UglifyJsPlugin插件进行压缩、混淆。

2、优化命令行构建日志

使用`friendly-errors-webpack-plugin`优化控制台信息展示，不同程度会有不同颜色。

success  warning  error，stats设置成errors-only

```javascript
const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin';)
plugins: [new FriendlyErrorsWebpackPlugin()],
stats: 'errors-only',
```

3、多进程多实例构建。使用 thread-loader 解析资源：每次 webpack 解析一个模块，thread-loader 会将它及它的依赖分配给 worker 线程中

```javascript
module: {
  rules: [
    {
      test: /\.js$/,
      use: [
        {
          loader: 'thread-loader',
          options: { workers: 3 },
        },
        'babel-loader',
      ],
    },
  ],
},
```

4、多进程多实例并行压缩

使用terser-webpack-plugin 开启 parallel 参数

```javascript
const TerserPlugin = require('erser-webpack-plugin');
……
optimization: {
  minizer: [
    new TerserPlugin({
      parallel: 4
    }),
  ],
},
```

5、利用浏览器缓存。

在做了众多代码分离的优化后，其目的是为了利用浏览器缓存，达到提高访问速度的效果。例如将固定的第三方模块抽离，下次修改了业务代码，重新发布上线不重启服务器，用户再次访问服务器就不需要再次加载第三方模块了。

但此时会遇到一个问题，如果再次打包上线不重启服务器，客户端会把以前的业务代码和第三方模块同时缓存，再次访问时依旧会访问缓存中的业务代码，所以会导致业务代码也无法更新

需要在output节点的filename中使用placeholder语法，根据代码内容生成文件名的hash。

```javascript
output: {
    // path.resolve解析当前相对路径的绝对路径
    path: path.resolve("./dist"),
    // 生成文件中添加8位的hash值，使更新业务代码时，避免使用缓存，导致页面内容没有更改
    filename: "[name].[contenthash:8].js",
  },
```

之后每次打包业务代码时，如果有改变，会生成新的hash作为文件名，浏览器就不会使用缓存了，而第三方模块不会重新打包生成新的名字，则会继续使用缓存。

开启缓存：会在node_modules下生成.cache目录文件

添加缓存.cache；使用缓存 cache 字段 和 babel-cache `cacheDirectory: true`

6、noParse

 在引入一些第三方模块时，并且其内部没有依赖其他模块。如果此时webpack去解析他们的内部依赖关系，是非常浪费时间的，需要组织webpack浪费时间去解析这些明知道没有依赖的库。

可以在webpack配置文件的`module`节点下加上`noParse`，并配置正则来确定不需要解析依赖关系的模块。

```javascript
module: {
    noParse: /jquery|bootstrap/,
}
```

### babel的原理

1. Parser 解析：是将 ES6 语法解析为 AST 抽象语法树。简单地说就是将代码打散成颗粒组装的对象。这一步主要是通过 babylon 插件来完成。
2. Transformer 转换：将打散的 AST 语法通过配置好的 plugins（babel-traverse 对 AST 进行遍历转译）和 presets （es2015 / es2016 / es2017 / env / stage-0 / stage-4 其中 es20xx 表示转换成该年份批准的标准，env 是最新标准，stage-0 和 stage-4 是实验版）转换成新的 AST 语法。这一步主要是由 babel-transform 插件完成。plugins 和 presets 通常在 .babelrc 文件中配置。
3. Generator 生成：将新的 AST 语法树对象再生成浏览器都可以识别的 ES5 语法。这一步主要是由 babel-generator 插件完成。

## 实操

### 实现上拉加载下拉刷新

**上拉加载**：本质是页面触底，或者快要触底时的动作

- `scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值
- `clientHeight`:它是一个定值，表示屏幕可视区域的高度；
- `scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)

综上我们得出一个触底公式：

```js
scrollTop + clientHeight >= scrollHeight
```

简单实现

```js
let clientHeight  = document.documentElement.clientHeight; //浏览器高度
let scrollHeight = document.body.scrollHeight;
let scrollTop = document.documentElement.scrollTop;
 
let distance = 50;  //距离视窗还有50的时候，开始触发；

if ((scrollTop + clientHeight) >= (scrollHeight - distance)) {
    console.log("开始加载数据");
}
```

**下拉刷新**：本质是页面本身置于顶部时，用户下拉时需要触发的动作

关于下拉刷新的原生实现，主要分成三步：

- 监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；
- 监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；
- 监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置

```js
// 监听`touchstart`事件，记录初始的值
var _element = document.getElementById('refreshContainer'),
    _refreshText = document.querySelector('.refreshText'),
    _startPos = 0,  // 初始的值
    _transitionHeight = 0; // 移动的距离

_element.addEventListener('touchstart', function(e) {
    _startPos = e.touches[0].pageY; // 记录初始位置
    _element.style.position = 'relative';
    _element.style.transition = 'transform 0s';
}, false);
```

```js
// 监听`touchmove`移动事件，记录滑动差值
_element.addEventListener('touchmove', function(e) {
    // e.touches[0].pageY 当前位置
    _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值

    if (_transitionHeight > 0 && _transitionHeight < 60) { 
        _refreshText.innerText = '下拉刷新'; 
        _element.style.transform = 'translateY('+_transitionHeight+'px)';

        if (_transitionHeight > 55) {
            _refreshText.innerText = '释放更新';
        }
    }                
}, false);
```

```js
// 最后，就是监听`touchend`离开的事件
_element.addEventListener('touchend', function(e) {
    _element.style.transition = 'transform 0.5s ease 1s';
    _element.style.transform = 'translateY(0px)';
    _refreshText.innerText = '更新中...';
    // todo...

}, false);
```







