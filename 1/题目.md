https://juejin.cn/post/6844903890270289928#heading-15

### void

```javascript
void  0; //undefined
void (0);//undefined
void (); //SyntaxError 语法错误
```

### toString

```javascript
2.toString(); // 报错，. 优先被解析为小数点
2..toString()； // '2'
2 .toString(); // '2'
(2).toString(); // '2'
```

### 变量提升

let const var区别

| **区别**           | **var** | **let** | **const** |
| ------------------ | ------- | ------- | --------- |
| 是否有块级作用域   | ×       | ✔️       | ✔️         |
| 是否存在变量提升   | ✔️       | ×       | ×         |
| 是否添加全局属性   | ✔️       | ×       | ×         |
| 能否重复声明变量   | ✔️       | ×       | ×         |
| 是否存在暂时性死区 | ×       | ✔️       | ✔️         |
| 是否必须设置初始值 | ×       | ×       | ✔️         |
| 能否改变指针指向   | ✔️       | ✔️       | ×         |

```javascript
var a = 10;
function foo() {
    console.log(a); // ??
    var a = 20;
}
foo(); // undefined
```

```javascript
var a = 10;
function foo() {
    console.log(a); // ??
    let a = 20;
}
foo(); // ReferenceError：a undefined
```

`let`和`const`声明可以让变量在其作用域上受限于它所使用的块、语句或表达式。与`var`不同的是，这些变量没有被提升，并且有一个所谓的**暂时死区(TDZ)**。试图访问**TDZ**中的这些变量将引发`ReferenceError`，因为只有在执行到达声明时才能访问它们。

### for循环头部var

```javascript
var array = [];
for(var i = 0; i <3; i++) {
 array.push(() => i);
}
var newArray = array.map(el => el());
console.log(newArray); // [3, 3, 3]
```

原因：在`for`循环的头部声明带有`var`关键字的变量会为该变量创建单个绑定（存储空间），三个箭头函数体中的每个`'i'`都指向相同的绑定。如果使用 `let` 声明一个具有块级作用域的变量，则为每个循环迭代创建一个新的绑定。

> let声明的变量在块级作用域({}包裹内部)有效。ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

**循环和闭包**

根据作用域的原理，尽管循环中的五个函数都是在各自迭代中分别定义的，但是他们都封闭在一个共享的全局作用域中，因此实际上只有一个 `i`。即所有函数共享一个 `i` 的引用。

```javascript
for(var i = 0; i < 5; i++) {
    setTimeout(() => {
        console.log(i);
    }, i * 1000);
}
// 输出5 5 5 5 5
```

改成如下，就可实现 每个迭代在运行时都会给自己 "捕获" 一个 `i` 的副本。在每次迭代内使用 IIFE（立即执行函数）会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代内部都会含有一个具有正确值的变量可以访问。

```javascript
for(var i = 0; i < 5; i++) {
    (function(j){
        setTimeout(() => {
            console.log(j);
        }, j * 1000);
    })(i)
}
```

或者：

```javascript
for(let i = 0; i < 5; i++) {
    setTimeout(() => {
        console.log(i);
    }, i * 1000);
}
```

### 避免迭代导致栈溢出

以下递归代码，可以通过传入参数 n，让代码递归执行 n 次，也就意味着调用栈的深度能达到 n，当输入一个较大的数时，比如 50000，就会出现栈溢出的问题，优化代码解决栈溢出。

```javascript
function runStack (n) { 
  if (n === 0) return 100; 
  return runStack( n- 2);
}
runStack(50000)
```

==方法一==：使用setTimeout

```javascript
function runStack (n) {
  if (n === 0) return 100;
  return setTimeout(function(){runStack( n- 2)},0);
}
runStack(50000)
```

原理：“浏览器是 JS 的家”真正的意思是浏览器提供运行时环境来执行JS代码。

浏览器的主要组件包括**调用堆栈**，**事件循环**，**任务队列**和**Web API**。 像`setTimeout`，`setInterval`和`Promise`这样的全局函数不是JavaScript的一部分，而是 Web API 的一部分。 JavaScript 环境的可视化形式如下所示：

<img src="https://images-sally.oss-cn-beijing.aliyuncs.com/images/2022-01-05-%E5%A0%86%E6%A0%88%E5%92%8Cwebapi-7beb0c69821d130dc715b214851cc36b-6a3.png" alt="堆栈和webapi" style="zoom:50%;" />

事件循环(Event loop)不断地监视任务队列(Task Queue)，并按它们排队的顺序一次处理一个回调。每当调用堆栈(call stack)为空时，Event loop获取回调并将其放入堆栈(stack )中进行处理。请记住，如果调用堆栈不是空的，则事件循环不会将任何回调推入堆栈。

1、调用 `runStack()`会将`runStack`函数放入**调用堆栈(call stack)**。
2、在处理内部代码时，JS引擎遇到`setTimeout`。
3、将`runStack`回调函数传递给**WebAPIs**并从函数返回，调用堆栈再次为空
4、计时器被设置为0，因此`runStack`将被发送到**任务队列**(箭头2)。
5、由于调用堆栈是空的，事件循环将选择`runStack`回调并将其推入调用堆栈进行处理。
6、进程再次重复，堆栈不会溢出。

==方法二==：蹦床函数，避免递归，将递归执行转为循环执行。

```javascript
function runStack (n) {
  if (n === 0) return 100;
  // 返回自身的一个版本，没有继续执行，函数已经返回了，所以会出栈
  return runStack.bind(null, n- 2); 
}
// 蹦床函数，避免递归
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}
trampoline(runStack(1000000))
```

1、`runStack(1000000)`入栈执行，返回自身一个版本，已经有返回，所以出栈，栈空
2、`trampoline`执行，入栈，栈内1个
3、执行f()，入栈，栈内2个；返回自身一个版本，已经有返回，所以出栈，栈内仅存`trampoline`1个
4、`runStack`的不同版本循环入栈出栈，使栈内一直只有`trampoline`

### 闭包+堆栈存储

```javascript
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName()); // "极客邦"
```

1、当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。

2、在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。

3、接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。

4、由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中

### 实现模版字符串替换

```javascript
function render(template, context) {
  return template.replace(/\{\{(.*?)\}\}/g, (match, key) => context[key.trim()]);
}
const template = "{{name   }}很厉name害，才{{age   }}岁";
const context = { name: "jawil", age: "15" };
console.log(render(template, context));
```

### 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组

```javascript
Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b});
```

### 数据类型

如何让：`a == 1 && a == 2 && a == 3`

```javascript
const a = {
   value:[3,2,1],
   valueOf: function () {return this.value.pop(); },
} 
```

包装类型是对象

```javascript
var a = new Boolean( false );
if (!a) {
	console.log( "Oops" ); // never runs，a是对象
}
```

```javascript
'foo' == new function() { return new String('foo')} // true
'foo' == new function() { return String('foo')} // false
```

### 数组引用的内存地址，内存地址的数据没变

```javascript
let person = { name: 'Sally' };
const members = [person];
person = null;
console.log(members); // [ { name: 'Sally' } ]
```
### 运算符优先级

```javascript
const name = 'Sally';
console.log(!typeof name === 'object'); // false
console.log(!typeof name === 'string'); // false
```
```javascript
class Counter {
  #number = 0; // #开头定义私有变量
  increment() {
    this.#number++;
  }
  getNum() {
    return this.#number;
  }
}
const counter = new Counter()
counter.increment();
console.log('##', counter.number, counter.getNum());
```
### then()返回仍然是promise

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() => {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() => {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)
```

输出：

```
promise1 Promise {<pending>}
promise2 Promise {<pending>}
Uncaught (in promise) Error: error!!!
promise1 Promise {<fulfilled>: "success"}
promise2 Promise {<rejected>: Error: error!!}
```

```javascript
Promise.resolve().then(() => {
  return new Error('error!!!')
}).then(res => {
  console.log("then: ", res)
}).catch(err => {
  console.log("catch: ", err)
})
```

输出：

```
"then: " "Error: error!!!"
```

### 捕获异常

```javascript
Promise.reject('err!!!')
  .then((res) => {
    console.log('success', res)
  }, (err) => {
    console.log('error', err)
  }).catch(err => {
    console.log('catch', err)
  })
```

输出：

```
error err!!!
```

### this

```javascript
function foo() {
  console.log( this.a );
}
function doFoo() {
  foo();
}
var obj = {
  a: 1,
  doFoo: doFoo
};

var a = 2; 
obj.doFoo()
// 2
```

```javascript
var a = 10
var obj = {
  a: 20,
  say: () => {
    console.log(this.a)
  }
}
obj.say();
var anotherObj = { a: 30 } 
obj.say.apply(anotherObj)  // 10 10 箭头函数不绑定this，它的this来自原其父级所处的上下文

var a = 10  
var obj = {  
  a: 20,  
  say(){
    console.log(this.a)  
  }  
}  
obj.say()   
var anotherObj={a:30}   
obj.say.apply(anotherObj) // 20 30
```

1. o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；
2. obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；
3. obj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。

```javascript
var obj = {
   say: function() {
     var f1 = () =>  {
       console.log("1111", this);
     }
     f1();
   },
   pro: {
     getPro:() =>  {
        console.log(this);
     }
   }
}
var o = obj.say;
o();
obj.say();
obj.pro.getPro();

// 1111 window对象
// 1111 obj对象
// window对象
```

```javascript
const button = new test();
const co = document.getElementById('test');
co.addEventListener('click', button.change);

function test() {
  this.flag = false;
  this.change = () => {
    this.flag = true;
    console.log(button.flag);
  };
}
// 箭头函数的this 绑定的一直是test 构造函数
// true
```

### 作用域

```javascript
(function(){
   var x = y = 1;
})();
var z;

console.log(y); // 1
console.log(z); // undefined
console.log(x); // Uncaught ReferenceError: x is not defined
```

```javascript
// a
function Foo () {
 getName = function () {
   console.log(1);
 }
 return this;
}
// b
Foo.getName = function () {
 console.log(2);
}
// c
Foo.prototype.getName = function () {
 console.log(3);
}
// d
var getName = function () {
 console.log(4);
}
// e
function getName () {
 console.log(5);
}

Foo.getName();           // 2
getName();               // 4 d e都会变量提升，d赋值覆盖
Foo().getName();         // 1 this 指向window，将全局getName重新赋值
getName();               // 1 同上
new Foo.getName();       // 2 先执行Foo.getName()，在执行new
new Foo().getName();     // 3
new new Foo().getName(); // 3
```

```javascript
var a = 'w';
let obj = {
  a: '0',
  print: function() {
    console.log(this.a);
  },
  print2: () => {
    console.log(this.a);
  }
};

let p = obj.print;
let p2 = obj.print2;
obj.print();
obj.print2();
p();
p2();
// 0 w w w
```

```javascript
var a = 100;
function a() {
  var a = 200;
  console.log(a);
}
a();
// 抛出异常，因为函数提升在 属性提升前面
```

### 构造函数

```javascript
var F = function() {};
Object.prototype.a = function() {
  console.log('a');
};
Function.prototype.b = function() {
  console.log('b');
}
var f = new F();
f.a();
f.b();
F.a();
F.b()
```

输出结果：

1. f 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a ，而 f.b() 就报错了。
2. F 是构造函数，是构造函数 Function 的一个实例。因为 `F instanceof Object === true，F instanceof Function === true`，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。

```
a
Uncaught TypeError: f.b is not a function
a
b
```

```javascript
function A(x){
  this.x = x;
}
A.prototype.x = 1;
 
function B(x){
  this.x = x;
}
B.prototype = new A();
var a = new A(2), b = new B(3);
delete b.x;
// b.x undefined
```

### 形参

简单类型传值，复杂类型传递引用

```javascript
var bb = 1;
function aa(bb) {
  bb = 2;
  alert(bb)
}
aa(bb);
alert(bb);

// 2 1
```

### 暂时性死区

```javascript
let x = 10;
let foo = () => {
  console.log(x);
  let x = 20;
  x++;
}
foo(); // 抛出ReferenceError
```













