数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法

<img src="https://images-sally.oss-cn-beijing.aliyuncs.com/images/2022-01-26-913e0ababe43a2d57267df5c5f0832a7-7fd2fd254cfdb59ece16e8e788e751f0-820.jpg" alt="img" style="zoom:50%;" />

数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树

算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

## 复杂度分析

时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

### 时间复杂度O

`T(n) = O(f(n))`：；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比

O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

总的时间复杂度就等于量级最大的那段代码的时间复杂度；嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

多项式量级：O(1)  O(logn) O(n) O(nlogn)  O($n^k$)

非多项式量级：O($2^n$) O(n!)

#### O(1)

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

#### O(logn) O(nlogn)

不论底数是什么，把所有对数阶的时间复杂度都记为 O(logn)

```c
i=1;
while (i <= n)  {
   i = i * 3;
}
```

以上例子中：第3行执行次数最多，为 $\log_3n$，时间复杂度记为：O(logn)

#### 时间复杂度分析

```c
// n表示数组array的长度
int find(int[] array, int n, int x) { 
  int i = 0; 
  int pos = -1; 
  for (; i < n; ++i) { 
    if (array[i] == x) { 
      pos = i; break; } 
  } 
  return pos;
}
```

最好情况时间复杂度：1次

最差情况时间复杂度：O(n)

平均情况时间复杂度：概率论计算过程：$\frac{1}{2n}(1+2+3+…+n)+\frac{n}{2} = \frac{3n+1}{4}$，所以是O(n)

均摊时间复杂度

### 空间复杂度

常见的空间复杂度就是 O(1)、O(n)、O($n^2$ )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到

线性表: 数据排成像一条线一样的结构.每个线性表上的数据最多只有前和后两个方向. 非线性表: 数据之间并不是简单的前后关系. 线性表数据结构包括: 数组,链表,队列,栈。非线性表数据结构包括: 二叉树,堆,图

## 数组

内存寻址

一维数组：`a[k]_address = base_address + k * type_size`

如果数组中的数据是有序的，在某个位置插入一个新的元素时，就需要将它之后的所有数据地址都往后般移。但如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，可以直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。

插入、删除：O(n)

随机访问第 K个元素：O(1)

## 链表

数组需要一块连续的内存空间来存储。链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用

单链表、循环链表、双链表、双向循环链表

### 单链表

每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。头节点用来记录链表的基地；尾节点，指针不是指向下一个节点， 而是指向null。

链表的插入和删除：只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)

随机访问第 K个元素：O(n)

### 循环链表

特殊的单链表。跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址。而循环链表的尾结点指针是指向链表的头结点。

### 双向链表

单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

![image-20220210150421540](https://images-sally.oss-cn-beijing.aliyuncs.com/images/2022-02-10-image-20220210150421540-b836d906f57836cb3a81babb3b855b78-4e0.png)

## 栈

先进后出的线性表，只能在一头进行插入和删除。用数组实现的栈是顺序栈，用链表实现的栈是链式栈

应用：函数的调用栈、浏览器的前进后退

## 队列

queue，先进先出的线性表，只能队头插入数据，只能队尾删除数据。用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。

## 递归

去的过程叫“递”，回来的过程叫“归”。写递归代码最关键的是写出递推公式，找到终止条件

递归需要满足3个条件：1. 一个问题的解可以分解为几个子问题的解；2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；3. 存在递归终止条件。

举例：假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？

```typescript
let map = new Map();
function climbStair(n: number) {
  if (n === 1) return 1;
  if (n === 2) return 2;

  // 避免重复计算
  if(map.get(n)) return map.get(n);
  let res = climeStair(n - 1) + climbStair(n - 2);
  map.set(n, res);

  return res;
}
```

递归需要警惕：堆栈溢出；重复计算

## 排序

|      | 是原地排序 | 是否稳定 | (最好)时间复杂度 | 最坏时间复杂度  | 平均时间复杂度  | 空间复杂度 |
| ---- | ----- | ---- | --------- | -------- | -------- | ----- |
| 冒泡排序 | ✅     | ✅    | O(n)      | O(n^2^)  | O(n^2^)  | O(1)  |
| 插入排序 | ✅     | ✅    | O(n)      | O(n^2^)  | O(n^2^)  | O(1)  |
| 选择排序 | ✅     | ✅    | O(n^2^)   | O(n^2^)  | O(n^2^)  | O(1)  |
| 归并排序 | ✅     | ✅    | O(nlogn)  | O(nlogn) | O(nlogn) |       |

| 算法  | 文件               |
| --- | ---------------- |
| 冒泡  | bubbleSort.ts    |
| 插入  | insertSort.ts    |
| 选择  | selectionSort.ts |
| 归并  | mergeSort.ts     |
